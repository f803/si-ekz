//12 Понятие дерева. Классификация деревьев

Дерево – это лес, состоящий из одного связного компонента (т.е. из одного дерева). (рекурсивное определение).

Дерево – это граф без циклов. (с точки зрения теории графов).

Дерево – древовидная структура данных, в которой значения всех узлов, размещённых правее некоторого узла, больше значений узлов, размещённых левее, 
причём это справедливо как для всего дерева, так и для любой его части.

Деревья или, в более широком смысле, древовидные структуры данных, представляют собой динамические связные структуры, отличающиеся от списков тем, 
что система связей не носит линейного характера, а образует ветви, подобно природному дереву.

Классификация

Эти структуры данных в общем случае можно разделить на две группы, которые отличаются друг от друга способом построения и (как следствие) реализацией процедур обработки – собственно деревья и пирамиды.

  двоичные(или бинарные) – имеющие не более двух ветвей;

  – с числом ветвей больше 2 – часто такие деревья называют мультивариантными (многопутевыми) или K-деревьями (т.е. K-мерными).

Важным признаком является состояние сбалансированности дерева и способы его достижения. Деревья могут быть:

  – сбалансированными;
  – идеально сбалансированными;
  – вырожденными;
  – отличающимися более или менее сильно от сбалансированных и от вырожденных.

Ещё один важный признак классификации – применение деревьев. Деревья поиска или сортировки.

//13 Операции с деревьями.
    
typedef struct node{
  int key;
  struct node *left, *right;
}NODE, *pNODE;

//добавление узла
pNODE addnode(int x, pNODE root){
  if (!root){
    root =(pNODE) malloc (sizeof(NODE));
    if (root){
      root->key=x;
      root->left=NULL;
      root->right=NULL;
  }
}
  else
    if (x<root->key)
      root->left=addnode (x,root->left);
    else
      root->right=addnode (x,root->right);
  return root;
}

//прохождение дерева
// нисходящее
void preorder (pNODE root){
  if (root){
    printf("%d;",root->key);
    preorder (root->left);
    preorder (root->right);
  }
}

//восходящее
void postorder(pNODE root){
  if (root){
    postorder (root->left);
    postorder (root->right);
    printf("%d;",root->key);
  }
}

//последовательное
void inorder (pNODE root){
  if (root){
    inorder (root->left);
    printf ("%d;",root->key);
    inorder (root->right);
  }
}

//поиск узла в дереве
pNODE find_tree (pNODE root, int val){
  if (!root) return NULL;
  if(val==root->key) return root;
  if(val<root->key) return find_tree(root->left, val);
  if(val>=root->key) return find_tree(root->right,val);
}

//поиск крайнего правого элемента
int rightmost (pNODE root){
  while (root->right)
    root=root->right;
  return root->key;
}

//удаление узла из дерева
pNODE del_tree (pNODE root, int val){
  if (!root) return NULL;
  if (root->key==val){
    if(!(root->left) && !(root->right)){
      free (root);
    return NULL;
    }
    if(!(root->right)&& root->left){
      pNODE temp= root->left;
      free(root);
      return temp;
    }
    if(!(root->left) && root->right){
      pNODE temp= root->right;
      free (root);
      return temp;
    }
    root->key=rightmost(root->left);
    root->left=del_tree(root->left,root->key);
    return root;
  }
  if (val< root->key){
    root->left=del_tree(root->left, val);
    return root;
  }
  if (val>=root->key){
    root->right=del_tree(root->right, val);
    return root;
  }
  return root;
}

//подсчет узлов
void Nnodes (pNODE root, int *p){
  if (!root) return;
    (*p)++;
    Nnodes(root->left, p);
    Nnodes(root->right, p);
}

//определение высоты дерева
void Height(pNODE root, int p,int* h){
  if(!root) return;
  p++;
  if(!(root->left) && !(root->right))
    if(p>*h) *h=p;
  Height(root->left,p,h);
  Height(root->right,p,h);
}

//удаление всех узлов
void del_all(pNODE *root){
  if (!*root) return;
  del_all (&(*root)->left);
  del_all (&(*root)->right);
  free (*root);
  *root = NULL;
}

//14 Сбалансированные деревья.

Максимальный эффект использования двоичного дерева поиска достигается, если оно сбалансировано – когда все узлы, кроме терминальных, 
имеют непустые и правый и левый соседние узлы; все поддеревья, начинающиеся с одного и того же уровня, имеют одинаковую высоту.

Сбалансированное бинарное дерево – максимально широкое и низкое.

Менее строгое, но практически более удобное определение сбалансированности дерева – дерево является сбалансированным, если для каждого узла исходящие ветви отличаются по 
высоте не более, чем на один уровень.

Для двоичного идеально сбалансированного дерева с максимально возможным (для идеальной сбалансированности) числом узлов существуют простые соотношения между этим числом узлов 
Nузлов и высотой дерева (т.е. числом уровней) nуровней :

Nузлов = 2Nуровней − 1

Nуровней = log2(Nузлов + 1)

Состояние сбалансированности часто оказывается настолько важным для тех областей, в которых деревья применяются, что для достижения этого состояния принимают специальные меры. 
Такими мерами являются либо та или иная операция балансировки (принудительной) дерева, в том числе включающая в себя упомянутые операции поворотов, либо использование 
специальных видов деревьев, обеспечивающих балансировку при каждой операции добавления или удаления узла.

//15 Рекурсивные функции. Этапы выполнения.

Рекурсия — вызов функции из неё же самой, непосредственно (простая рекурсия) или через другие функции (сложная или косвенная рекурсия), 
например, функция A вызывает функцию B, а функция B — функцию A.
  
Что происходит, если одна функция вызывает другую? В общих чертах следующее:

· в памяти размещаются параметры, передаваемые функции (но не параметры-переменные, т. к. они передаются по ссылке!);
· для внутренних переменных вызываемой функции также отводится новая область памяти (несмотря на совпадение их имен и типов с переменными вызывающей функции);
· запоминается адрес возврата в вызывающую функцию;
· управление передается вызванной функции.

double Rec_Fact(int n){
  if (n <= 1)
    return 1.0;
  else 
    return Rec_Fact(n-1)*n;
}

unsigned long fib(int n){
  if(n==0 || n==1)
    return 1;
  else
    return fib(n-1)+fib(n-2);
}

double Rec_step(float a,int b){
  if(b <= 0) 
    return 1.0;
  else
    return Rec_step(a,b-1)*a;
}

double rec_degree(double a,int b){
  double r;
  if(!b)
    return 1;
  if(!(b%2))
    return r=rec_degree(a,b/2), r*r;
  else 
    return a*rec_degree(a,b-1);
}

int NOD_rec(int a,int b){
  if(!(a%b))
    return b;
  else
    return NOD_rec(b,a%b);
}

void printd(int k){
  if(k<0){
    putchar('-');
    k= -k;}
  if(k/10)
    printd(k/10);
  putchar(k%10 +'0');
}

void Reverse(){
  int ch;
  if((ch=getchar()) !='\r'){
    Reverse();
    putchar(ch);
  }
}

int sum(int *s,int n){
  if(n==1)
    return s[0];
  else
    return sum(s,n-1) + s[n-1];
}

//16 Формы рекурсивных функций.

Существует три разных формы рекурсивных программ:

1. Форма с выполнением действий до рекурсивного вызова (с выполнением действий на рекурсивном спуске).
2. Форма с выполнением действий после рекурсивного вызова (с выполнением действий на рекурсивном возврате).
3. Форма с выполнением действий как до, так и после рекурсивного вызова (с выполнением действий, как на рекурсивном спуске, так и на рекурсивном возврате).

//17 Виды рекурсий.
  
Рекурсия может быть прямой и косвенной.

В случае прямой рекурсии вызов функцией самой себя делается непосредственно в этой же функции:

      void f() {
      ............
      f();
      ............
      }

Косвенная рекурсия создаётся за счёт вызова данной функции из какой-либо другой функции, которая сама вызывалась из данной функции.

//18 Указатель на функцию.
  
Указатель на функцию представляет собой выражение или переменную, которые используются для представления адреса функции. Указатель на функцию содержит адрес первого байта в 
памяти, по которому располагается выполняемый код функции.
  
Адрес, присвоенный указателю, является входной точкой в функцию. Указатель может использоваться вместо имени функции. Он также позволяет передавать функции как обычные 
аргументы в другие функции.

Указатели на функции задаются следующим образом:

    1) void f() { } 
    2) void (*pf)() = &f; 
    3) pf();

В этом коде f - некоторая функция. Во второй строчке определяется переменная pf, которая является указателем на функцию, которая ничего не возвращает и не принимает ни одного 
аргумента. В определении pf ей присваивается адрес функции f. В третьей строке мы вызываем функцию по указатели pf(в данном случае будет вызвана функция f).

//19 Обобщенные алгоритмы.
  
Алгоритмы STL представляют собой обобщённые численные алгоритмы (заголовочный файл <numeric>). Это не какие-то особые вычислительные методы, как можно подумать исходя из 
названия. Это алгоритмы, позволяющие применять общеизвестные библиотечные или свои собственные вычислительные функции ко всей совокупности элементов контейнера.

А поскольку так, то и вызываются они подобно всем другим алгоритмам STL. Используются такие обобщённые алгоритмы, главным образом в математических вычислениях применительно к 
контейнерам, содержащим числовые элементы.

Перечислим представленные STL обобщённые численные алгоритмы: iota (создание монотонно возрастающей последовательности), accumulate (накопление), inner_product 
(скалярное произведение), partial_sum (частичная сумма), adjacent_difference (смежная разность).

//20 Стек. Примеры. Основные операции над стеком.

Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).

Программный вид стека используется для обхода структур данных, например, дерево или граф. 
При использовании рекурсивных функций также будет применяться стек, но его аппаратный вид. Кроме этих назначений, стек используется для организации стековой машины, 
реализующей вычисления в обратной польской записи. Примером использования стековой машины является программа Unix dc.
Для отслеживания точек возврата из подпрограмм используется стек вызовов.
Арифметические сопроцессоры, программируемые микрокалькуляторы и язык Forth используют стековую модель вычислений.
Идея стека используется в стековой машине среди стековых языков программирования.

Операции стека:
  1) Проверка стека на пустоту
  2) Дабавление элемента
  3) Вывод стека на экран
  4) Извлечение элемента из стека
  5) Очистка стека
  5) Создание стека

//21 Создание стека. Функция создания нового стека.

typedef struct Node{
  char val;
  struct Node *next;
}NODE,*pNODE;

typedef struct Stack{
  pNODE top;
  int len;
}STACK,*pSTACK;

pSTACK createstack(){
  pSTACK ps;
  ps = (pSTACK)malloc(sizeof(STACK));
    ps->top = NULL;
    ps->len = 0;
    return ps;
}

// 22 Функция проверки наполненности стека.

int isempty(pSTACK ps){
  if(ps->top) return 0;
  return 1;
}

// 23 Функция добавления элемента в стек.

void push(pSTACK ps, char value){
  pNODE p = (pNODE)malloc(sizeof(NODE));
  p->val = value;
  p->next = ps->top;
  ps->top = p;
  ps->len++; 
}

// 24 Функция извлечения элемента из стека.

char pop(pSTACK ps){
  pNODE p = ps->top;
  int c = p->val;
  ps->top=p->next;
  free(p);
  ps->len--;
  return c;
}

// 25 Функция вывода стека на экран.

void show(pSTACK ps){
  pNODE p = ps->top;
    if(isempty(ps))puts("stack empty");
    else
    while(p){
      printf("%c", p->val);
      p = p->next;
    }
}

// 26 Функция очистки стека.

void clearstack(pSTACK ps){
  while(!isempty(ps))
    pop(ps);
    free(ps);
}

// 27 Тело программы.

int main(void){
  setlocale(LC_CTYPE,"Russian");
  pSTACK ps = createstack();
  char c;
  for(c='a';c<='{';c++)
    push(ps,c);
  while(!isempty(ps)){
    pop(ps);
    show(ps);
    printf("\n");
  }
  return 0;
}

// 28 Очередь. Операции очереди.

Очередью называется упорядоченный набор элементов, которые могут исключаться с одного ее конца (называемого началом очереди), 
а включаться с другого конца (называемого концом очереди).
Операции очереди:
  1) Проверка очереди на пустоту
  2) Дабавление элемента
  3) Вывод очереди на экран
  4) Изъятие элемента из очереди
  5) Очистка очереди
  6) Создание очереди

// 29 Области применения очереди.

Очередь в программировании используется, как и в реальной жизни, когда нужно совершить какие-то действия в порядке их поступления, выполнив их последовательно. 
Примером может служить организация событий в Windows. Когда пользователь оказывает какое-то действие на приложение, то в приложении не вызывается соответствующая процедура 
(ведь в этот момент приложение может совершать другие действия), а ему присылается сообщение, содержащее информацию о совершенном действии, это сообщение ставится в очередь, 
и только когда будут обработаны сообщения, пришедшие ранее, приложение выполнит необходимое действие.

Области применения очередей могут быть разделены на две группы – системное применение и прикладное. К применению очередей в системных целях относятся:

 - диспетчеризация задач операционной системой;
 - буферизация ввода/вывода;

Прикладное применение:

 - моделирование процессов (например, систем массового обслуживания);
 - использование очередей как вспомогательных структур данных в каких-либо алгоритмах (например, при поиске в графах).

// 30 Реализация очереди. Функция создания очереди.

typedef struct Node{
  int val;
  struct Node *next;
}NODE,*pNODE;

typedef struct queue{
  NODE *beg, *end;
  int len;
}QUEUE,*pQUEUE;

pQUEUE create(){
  pQUEUE pQ;
  pQ = (pQUEUE)malloc(sizeof(QUEUE));
  pQ->beg = NULL;
  pQ->end = NULL;
  pQ->len = 0;
  return pQ;
}

// 31 Функция проверки очереди на пустоту. Функция добавления элемента.

int isempty(pQUEUE pQ){
  if(pQ->beg == NULL) return 1;
  return 0;
}

void put(pQUEUE pQ, float value){
  pNODE pn;
  pn = (pNODE)malloc(sizeof(NODE));
  pn->next = NULL;
  pn->val = value;
  if(pQ->end != NULL) pQ->end->next = pn;
  else pQ->beg = pn;
  pQ->end = pn;
  pQ->len++;
}

// 32 Функция вывода очереди на экран. Функция изъятия элемента из очереди.

void show(pQUEUE pQ){
  pNODE p = pQ->beg;
    if(isempty(pQ))puts("empty");
    while(p){
      printf("%d", p->val);
      p = p->next;
    }
    printf("\n");
}

float take(pQUEUE pQ){
  pNODE p = pQ->beg;
  float c=p->val;
  pQ->beg = p->next;
  free(p);
  pQ->len--;
  return c;
}

// 33 Функция очистки очереди. Тело программы.

void ClearQueue(pQUEUE pQ){
  while(!isempty(pQ)){
    take(pQ);
  }
  free(pQ);
}

int main(void){
  pQUEUE pQ = create();
  int i;
  for(i = 1; i < 11;i++){
    put(pQ,i);
  }
  show(pQ);
  while(!isempty(pQ)){
    take(pQ);
    show(pQ);
  }
}
